---
title: "Dataimport of 2019 data - Planteimport"
author: "Jens Åström"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  NinaR::jensAnalysis:
    highlight: tango
    fig_caption: yes
    toc: yes
---


**To-do** 

* Check/ask if pdf_present is Correct for 2018 and 2019 data. Only "x" for 2019 data, but True for most in database.
* Check the transport type for the rest of the containers. Says boat for a few, and NA for the rest.

```{r, include = F}
#Some common packages, loading rmarkdown doesn't like the messages from tidyverse, so we don't include this in the document'
require(tidyverse)
require(DBI)
require(RPostgres)
require(ggplot2)
require(xtable)
require(NinaR)
require(dbplyr)
require(openxlsx)
```


```{r setup, include=FALSE}
#This is optional
#I choose the 'styler' package for tidying the code to preserve indentations
#I set the cutoff for code tidying to 60, but this doesn't currently work with styler.
#Set tidy = True to get the knitr default
#I want all figures as png and pdf in high quality in a subfolder called figure 

knitr::opts_chunk$set(echo = TRUE, 
                      tidy = "styler",
                      dev = c("png", "pdf"),
                      dpi = 600,
                      fig.path = "figure/",
                      tidy.opts = list(width.cutoff = 60),
                      eval = F
                      )

options(xtable.comment = F, 
        xtable.include.rownames = F, 
        nina.logo.y.pos = 0.15)
palette(ninaPalette())
```



```{r, include = F, eval = T}
#This connects to the gisdatabase with a DBI connection named `con`.
#Use for example dbGetQuery(con, "SELECT * FROM ....") to query the database
##Use your own "Windows" username and password
source("~/.rpgpass")
postgreSQLConnect(host = "ninradardata01.nina.no", 
                 dbname = "planteimport", 
                 username = username, 
                 password = password)
rm(list = c("username", "password"))
```


Intro
===========
This script imports the 2019 alien stowaway data to the database. 

So far, we only deal with the container samples, where we have both plant and invertebrate data from soil samples of imported pots.


Container data
===========
This will add new rows to the table `common.containers` (schema common, table containers).

We first see what the latest sample in the database currently is.

```{r}
conTab <- tbl(con, in_schema("common", "containers"))

conTab %>% 
  arrange(desc(container),
          subsample
          ) %>% 
  select(1:5)
```
So we have 87 containers and the last one is sampled in April 2018. 
Time to load the new data.
```{r}
newConDataRaw <- read.xlsx("../../rawData/data_2019/Database2018 med 2019-data konteinere.xlsx",
                        detectDates = T) %>% 
  as_tibble()

newConDataRaw %>% 
  select(1:8)
```

So we subset the new data to contain only 2019 data.

```{r}
conData2019 <- newConDataRaw %>% 
  filter(container > 87) #found above

conData2019 %>% 
  select(1:8)
```

And test an import, find out what's wrong and fix it.

```{r}
dbBegin(con)
dbWriteTable(con,
             Id(schema = "common", table = "containers"),
             conData2019,
             append = T)

dbRollback(con)
```

Fixes to the container data
==========
This came up through the quality check.

Change na/x to logical (yes/no).
----------
```{r}
conData2019 <- conData2019 %>% 
  mutate(pdf_present = as.logical(ifelse(is.na(pdf_present), FALSE, TRUE)),
         mattilsynet = as.logical(ifelse(is.na(mattilsynet), FALSE, TRUE)))


# tt %>% 
#   select(pdf_present,
#          mattilsynet) %>% 
#   print(n = Inf)
```

Change the missing country to unknown and translate country to English. Also change the almost duplicate names to one single (Tyskland/Nederland vs Nederland/Tyskland etc.)
------------
```{r}
conData2019 <- conData2019 %>% 
  mutate(country = ifelse(is.na(country), "Unknown", country)) %>% 
  mutate(country = ifelse(country == "Nederland", "Netherlands", country),
         country = ifelse(country == "Tyskland", "Germany", country),
         country = ifelse(country == "Tyskland/Nederland", "Germany, Netherlands", country),
         country = ifelse(country == "Litauen/Tyskland", "Germany, Lithuania", country),
         country = ifelse(country == "Italia", "Italy", country),
         country = ifelse(country == "Nederland/Tyskland", "Germany, Netherlands", country),
         country = ifelse(country == "Italia/Nederland", "Netherlands, Italy", country),
         country = ifelse(country == "Spania", "Spain", country),
         country = ifelse(country == "Danmark", "Denmark", country),
         country = ifelse(country == "Tyskland/Litauen", "Germany, Lithuania", country))


conData2019 %>% 
  select(country) %>% 
  distinct()
```

Add the new "countries" to the lookup table of countries.
```{r}
dbWriteTable(con,
             Id(schema = "common", table = "country"),
             tibble(country = c("Unknown",
                                "Germany, Netherlands",
                                "Germany, Lithuania",
                                "Netherlands, Italy",
                                "Spain")),
             append = T)
```


Tidy up exporter names and add new exporters to the lookup table.
---------------
```{r}
conData2019 %>% 
  select(exporter) %>% 
  arrange(exporter) %>% 
  distinct()


exporter <- tbl(con, 
                 in_schema("common", "exporter"))
exporter %>% 
  select(exporter) %>% 
  print(n = Inf)
```

These are the fixes I made.
```{r}
conData2019 <- conData2019 %>% 
  mutate(exporter = ifelse(exporter == "Aris B.V.", "Aris", exporter),
         exporter = ifelse(exporter == "Aris B V", "Aris", exporter),
         exporter = ifelse(exporter == "Aris B V / Plantagen Source GmbH", "Plantagen source, Aris", exporter),
         exporter = ifelse(exporter == "Floranordic bv .", "Floranordic", exporter),
         exporter = ifelse(exporter == "Floranordic bv,", "Floranordic", exporter),
         exporter = ifelse(exporter == "Noviflora Holland B.V.", "Noviflora Holland", exporter),
         exporter = ifelse(exporter == "Az agr Anania Patrizia - ME/19/0953", "Anania Patrizia", exporter),
         exporter = ifelse(exporter == "CATTANEO BRUNO S.r.l,", "Cattaneo Bruno", exporter),
         exporter = ifelse(exporter == "Elbers Export GmbH", "Elbers Export", exporter),
         exporter = ifelse(exporter == "3IAMBO' PIANTE Dl VITO GIAMBO' (cod. reg. ME/19/1627) / Aris B.V.", "GIAMBO PIANTE DI VITO GIAMBO, Aris", exporter),
         exporter = ifelse(exporter == "Noviflora Holland B.V.", "Noviflora Holland", exporter),
         exporter = ifelse(exporter == "PIantagen Source GmbH", "Plantagen source", exporter),
         exporter = ifelse(exporter == "PIantagen Source GmbH/JSC \"Eglesakis\"", "Plantagen source, Eglesakis", exporter),
         exporter = ifelse(exporter == "Plantagen Source GmbH", "Plantagen source", exporter),
         exporter = ifelse(exporter == "Plantagen Source GmbH", "Plantagen source", exporter),
         exporter = ifelse(exporter == "PROVAL, S.A.T. N° 362 C.V", "SAT N 362 CV PROVAL", exporter),
         exporter = ifelse(exporter == "Plantagen Source GmbH/Aris B V", "Plantagen source, Aris", exporter),
         exporter = ifelse(exporter == "GIAMBO' PIANTE Dl VITO GIAMBO' (cod. reg. ME/19/1627)", "GIAMBO PIANTE DI VITO GIAMBO", exporter),
         exporter = ifelse(exporter == "JSC \"Eglesakis\"/Plantagen Source GmbH", "Plantagen source, Eglesakis", exporter),
         exporter = ifelse(exporter == "Feldborg A/S", "Feldborg", exporter),
         exporter = ifelse(exporter == "Ikke i sertifikatet?", "Unknown", exporter),
         exporter = ifelse(exporter == "Sjekk - ikke i sertifikat", "Unknown", exporter)
         
         ) 


conData2019 %>% 
  select(exporter) %>% 
  arrange(exporter) %>% 
  distinct()
```

We compare this more compact list of exporters to what is already stored in the database.
```{r}
expInData <- 
  exporter %>% 
  select(id,
         expInData = exporter) %>% 
  collect()

conData2019 %>% 
  select(exporter) %>% 
  distinct() %>% 
  left_join(expInData, 
            by = c("exporter" = "expInData"))
```

And update the table with the missing exporters.

```{r}
expToImport <- conData2019 %>% 
  select(exporter) %>% 
  distinct() %>% 
  left_join(expInData, 
            by = c("exporter" = "expInData")) %>% 
  filter(is.na(id)) %>% 
  select(-id)

expToImport
```
```{r}
dbWriteTable(con, 
             Id(schema = "common", table = "exporter"),
             expToImport,
             append = T)
```

Update the missing transport_types. (I've added the "Boat" type to the lookup table)
----------------------
```{r}
conData2019 %>% 
  select(transport_type) %>% 
  distinct()

conData2019 <- conData2019 %>% 
  mutate(transport_type = ifelse(transport_type == "Båt", "Boat", transport_type))
  
```

Update the species list with the new import species
-------------------
Fix obvious errors, like trim white spaces and uppercase genus.

```{r}
conData2019 <- conData2019 %>% 
  mutate(species_latin = str_trim(species_latin)) %>% 
  mutate(species_latin = str_to_sentence(species_latin))
```

Change some naming errors.
```{r}
conData2019 <- conData2019 %>% 
  mutate(species_latin = ifelse(species_latin == "Juniperus chi", "Juniperus chinensis", species_latin),
         species_latin = ifelse(species_latin == "Salix capra", "Salix caprea", species_latin),
         species_latin = ifelse(species_latin == "Festicua glauca", "Festuca glauca", species_latin),
         species_latin = ifelse(species_latin == "Fragesia", "Fargesia", species_latin),
         species_latin = ifelse(species_latin == "Deschamsia caespitosa", "Deschamsia cespitosa", species_latin))
```

```{r}
impSpecies2019 <- conData2019 %>% 
  select(species_latin) %>% 
  distinct() %>% 
  arrange() 

plantSpeciesInDatabase <- tbl(con, in_schema("plants", "species"))

plantSpeciesInDatabase <- plantSpeciesInDatabase %>% 
  select(id, species_latin) %>% 
  distinct() %>% 
  arrange() %>% 
  collect()


plantsNotInDatabase <- impSpecies2019 %>% 
  left_join(plantSpeciesInDatabase,
            by = c("species_latin" = "species_latin"))
  



```
These are the new "species" in the container data for 2019. Some trailing white spaces and some genus names not capitalized.

```{r}
plantsNotInDatabase %>% 
  filter(is.na(id)) %>% 
  arrange() %>% 
  print(n = Inf)
```

Import new species names to the lookup table
-----------

```{r}
plantsToImport <- plantsNotInDatabase %>% 
  filter(is.na(id)) %>% 
  arrange(species_latin)  %>% 
  select(-id)

```
```{r}
dbWriteTable(con, Id(schema = "plants", table = "species"),
             plantsToImport,
             append = T)
```
Some of the new names had matches in artsdatabankens artsnavnebase, and those that didn't seemed to have the correct spelling.

Import the container data
---------
After this there is no further complaints from the database and we can import the data.

```{r}
dbWriteTable(con,
             Id(schema = "common", table = "containers"),
             conData2019,
             append = T)
```


Import the plant data
=============
I'm basing this on the excel file called "Spiretall NY planteimport.....", sheet nr 2. I've made another sheet where I get rid of the "contaminated" species (Betula pendula etc).

```{r}
plants2019Raw <- read.xlsx("../../rawData/data_2019/Spiretall NY planteimport-40-nytt prosjekt spiretall for karplanter.xlsx",
                           sheet = "Til_database") %>% 
  as_tibble()

plants2019 <- plants2019Raw %>% 
  arrange(container,
          subsample,
          species_latin)
```

I think container 84 and 87 realy are 94 and 97.
```{r}
plants2019

plants2019 <- plants2019 %>% 
  mutate(container = ifelse(container == 84, 94, container),
         container = ifelse(container == 87, 97, container))

```

Next, we sum the total amounts of every species in each subsample and vernalisation criterion.

```{r}
plants2019 <- plants2019 %>% 
  group_by(container,
           subsample,
           species_latin,
           vernalisation) %>% 
  summarise(amount = sum(amount)) %>% 
  ungroup()

plants2019 %>% print(n = Inf)

```

Next, we look at the species names that are new.

```{r}
plants2019 <- plants2019 %>% 
  mutate(species_latin = ifelse(species_latin == "Cirsium arvensis", "Cirsium arvense", species_latin),
         species_latin = ifelse(species_latin == "Lepidium didymus", "Lepidium didymum", species_latin),
         species_latin = ifelse(species_latin == "Lipandra polyspermum", "Lipandra polysperma", species_latin),
         species_latin = ifelse(species_latin == "Persicaria lapthatifolium coll.", "Persicaria lapathifolia", species_latin),
         species_latin = ifelse(species_latin == "Solanum nigrum ssp. sarracoides", "Solanum sarrachoides", species_latin),
         species_latin = ifelse(species_latin == "Urtica diolica", "Urtica dioica", species_latin))


```


Note: I changed the name "Arabis thaliana" to "Arabidopsis thaliana".

```{r}
plantNames2019 <- plants2019 %>% 
  select(species_latin) %>% 
  distinct() %>% 
  arrange(species_latin)


plantNames2019 %>% 
   left_join(plantSpeciesInDatabase) %>% 
   filter(is.na(id))
```
Import new plant names to the species table
----------

```{r}
plantNamesToImport <- plantNames2019 %>% 
   left_join(plantSpeciesInDatabase) %>% 
   filter(is.na(id)) %>% 
  select(-id)

dbWriteTable(con, Id(schema = "plants", table = "species"),
             plantNamesToImport,
             append = T)

```



```{r}
dbBegin(con)

dbWriteTable(con, Id(schema = "plants", table = "container_records"),
             plants2019,
             append = T)

dbRollback(con)

```
Again, aggregate the data after we've fixed the species names, just to make sure we didn't create any new duplicates.

```{r}
plants2019 <- plants2019 %>% 
  group_by(container,
           subsample,
           species_latin,
           vernalisation) %>% 
  summarise(amount = sum(amount)) %>% 
  ungroup()
```

And finally, import the new data.

```{r}
dbWriteTable(con, Id(schema = "plants", table = "container_records"),
             plants2019,
             append = T)
```




Invertebrates
===========
**To-do**


* Check what "x" means for several species. Here I have deleted these x'es
* Add a column in container table with preservation liquid. Some are propylenglycol in  the 2019 data.
* Add the comments of bad insect_liquid in some samples in container sample.
* Change the names that only have matches to not "Gyldig" artsnavn.



```{r}
inv2019Raw <- read.xlsx( "../../rawData/data_2019/Konteinerprøver_invertebrater-2019.xlsx", sheet = "To_database") %>% as_tibble()

inv2019Raw
```

```{r}
inv2019Raw %>% 
  select(`98-03`) %>% 
  print(n = Inf)

inv2019Raw %>% 
  mutate(`98-03` = as.double(`98-03`)) %>% 
  select(`98-03`) %>% 
  print(n = Inf)
```


```{r}
inv2019 <- inv2019Raw %>% 
  mutate_at(3:ncol(.), as.double)

inv2019 <- inv2019 %>% 
  pivot_longer(cols = -c(species_latin, stadium),
               names_to = "container")

inv2019 <- inv2019 %>% 
  separate(col = container,
           into = c("container", "subsample"),
           sep = "-") %>% 
  select(everything(),
         amount = value) %>% 
  mutate(amount = replace_na(amount, 0)) %>% 
  select(-stadium)
  
```
We don't include Null records before, i.e. species that weren't found in a sample. We continue with this practice here.

```{r}
inv2019 <- inv2019 %>% 
  filter(amount > 0)
```




Test import to temporary table

```{r}
dbSendStatement(con, "DROP TABLE IF EXISTS insects.cr_temp;")

dbSendStatement(con, "CREATE TABLE insects.cr_temp (LIKE insects.container_records INCLUDING ALL);")

dbSendStatement(con, "
  ALTER TABLE insects.cr_temp ADD CONSTRAINT cr_records_fk FOREIGN KEY (container, subsample)
        REFERENCES common.containers (container, subsample) MATCH FULL
        ON UPDATE CASCADE
        ON DELETE RESTRICT;")

dbSendStatement(con, "		
   ALTER TABLE insects.cr_temp ADD   CONSTRAINT crrecords_species_fk FOREIGN KEY (species_latin)
        REFERENCES insects.species (species_latin) MATCH FULL
        ON UPDATE CASCADE
        ON DELETE RESTRICT;
                ")

dbSendStatement(con,
                "INSERT INTO insects.cr_temp SELECT * FROM insects.container_records")

```

Check missing invertebrate names
-------------
I compare this missing list to what's in the database manually.

```{r}
invNamesInDatabase <- dbGetQuery(con,
                                 "SELECT id, species_latin FROM insects.species")

invNames2019 <- inv2019 %>% 
  select(species_latin) %>% 
  distinct() %>% 
  left_join(invNamesInDatabase,
            by = c("species_latin" = "species_latin")) %>% 
  filter(is.na(id)) %>% 
  arrange(species_latin)

invNames2019 %>% 
  print(n = Inf)
```


Add these species to the species table

```{r}
invNames2019 <- invNames2019 %>% 
  select(-id)

dbWriteTable(con, Id(schema = "insects", table = "species"),
             invNames2019,
             append = T)
```



```{r}
dbWriteTable(con, Id(schema = "insects", table = "cr_temp"),
             inv2019,
             append = T)
```
<!-- We can import this temporary, if we remove the foreign key to the species table -->

<!-- ```{r} -->
<!-- dbSendStatement(con, "ALTER TABLE insects.cr_temp DROP CONSTRAINT crrecords_species_fk;") -->
<!-- ``` -->

```{r}
dbWriteTable(con, Id(schema = "insects", table = "cr_temp"),
             inv2019,
             append = T)
```
Seems to work now. Importing in real table


```{r}
dbWriteTable(con, Id(schema = "insects", table = "container_records"),
             inv2019,
             append = T)
```

